I"<h1 id="목표">목표</h1>

<p>자바의 람다식에 대해 학습하세요.</p>

<h2 id="학습할-것">학습할 것</h2>

<ul>
  <li>람다식 사용법</li>
  <li>함수형 인터페이스</li>
  <li>Variable Capture</li>
  <li>메서드, 생성자 레퍼런스</li>
</ul>

<hr />

<h1 id="1-람다식이란">1. 람다식이란?</h1>

<p><code class="language-plaintext highlighter-rouge">람다식은 메서드를 하나의 식(expression)으로 표현한 것이며 익명 함수(anonymous 
        function)이라고도 한다</code></p>

<p><code class="language-plaintext highlighter-rouge">람다식은 람다식 자체로 메서드의 매개변수가 될 수 있고, 메서드의 결과로 반환될 수 있다는 것이 
핵심이며, 이를 first-class-function이라고 부른다. 이는 함수형 프로그래밍에 필수적이다.</code></p>

<p>물론 자바는 함수형 패러다임을 설계단계에서부터 고려한 다른 언어들과는 다르게 
순수한 객체지향 언어로 설계되었으며, 함수형 패러다임의 이점을 잘 가져오기 위해 
많은 노력이 들어간 결과물이 바로 자바의 람다식이다.</p>

<p>람다식을 사용하기에 앞서 <code class="language-plaintext highlighter-rouge">익명 객체(익명 클래스)</code> 라는 것에 대해 알면 좋다. <br />
아래와 같이 Functional이라는 인터페이스를 implements를 이용하여 
구현한 클래스를 만들지 않고 인터페이스를 바로 구현하여 사용하는 방법이 익명 
객체이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Functional</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">cal</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">);</span>
<span class="o">}</span> 

<span class="nc">Functional</span> <span class="n">functional</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Functional</span><span class="o">()</span> <span class="o">{</span> 
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">cal</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
             <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">;</span>
         <span class="o">}</span>
<span class="o">};</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">functional</span><span class="o">.</span><span class="na">cal</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">));</span>
</code></pre></div></div>

<p>위의 익명 구현 객체를 아래와 같이 람다식으로 한줄로 표현 가능하다.</p>

<blockquote>
  <p>익명 객체를 람다식으로 대체 가능한 이유?  <br />
    &gt; 인터페이스를 구현한 익명 객체의 메서드와 람다식의 매개변수 타입과 개수 그리고 반환 값이 일치하기 때문에 대체 가능하다.</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Functional</span> <span class="n">functional</span> <span class="o">=</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">;</span>
</code></pre></div></div>

<p>람다식 얘기에 앞서 굳이 익명 객체에 대해 언급한 이유는 
<code class="language-plaintext highlighter-rouge">익명 객체가 람다식으로 대체 될 수 있다고 해서 동작 방식과 특징이 
동일한 개념이라고 생각 할 수 있기 때문이다.</code></p>

<p>익명 클래스로 작성한 코드와 이를 람다로 대체한 코드 각각을 
바이트 코드를 비교해 보면 차이를 알 수 있다.</p>

<p><code class="language-plaintext highlighter-rouge">람다는 익명 클래스와 다르게 invokedynamic을 사용하는 것을 볼 수 있는데 
이는 아래와 같은 이점이 있다.</code></p>

<p>1) 미래의 최적화를 위해 특정 전략으로 고정하지 않은 것(즉, 최대한 바이트코드로 
    고정되어 컴파일 되지 않게 하는것)</p>

<p>특정 translation strategy (실제 자바 실행 로직으로 변환하는 과정 및 전략)을 
런타임에서 결정할 수 있다. 따라서, 미래에 변해서 JVM 스펙이 업데이트 되었다고 
하더라도 소스코드 수정이나, 재컴파일 없이 그대로 실행 가능하다!</p>

<p>만약 람다가 컴파일 타임에서 완벽하게 변환이 되었다고 한다면, 나중에 
수정사항이 있을 경우 프로젝트를 모두 재컴파일 해야 하는 일이 
생길 수 있다.</p>

<p>2) 클래스 파일 표현에 안정성을 가지는 방법</p>

<p>람다는 이 두가지의 모두 이점을 가지기 위해, <code class="language-plaintext highlighter-rouge">람다라는 표현 () -&gt; {} 을 실제 
자바 메서드 실행 로직(바이트 코드로 나온 실행 메서드)로 컴파일 타임이 아닌 
invokedynamic을 통해서 런타임에서 로직을 연결하고 실행한다. 이를 통해서, 
    실제 람다 표현을 실행하는 로직을 결정하는 전략을 런타임에서 lazy하게 
    결정할 수 있다는 장점이 있다.</code></p>

<p>다른 차이점에 대해서는 아래 Variable Capture 부분에서 자세히 설명 한다.</p>

<h2 id="11-람다식-사용법">1.1 람다식 사용법</h2>

<p>람다식은 생략 가능한 부분이 꽤 많기 때문에 헷갈릴 수 있지만, 기본적으로 
화살표를 기준으로 좌측에는 매개변수가 오고 우측에는 실행 코드가 작성 된다는 것을 
기억하면 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(매개변수) -&gt; {실행 코드}    
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Functional</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">cal</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Functional2</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Functional3</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">noArgs</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 1. 작성 가능한 모든 내용을 생략 없이 작성한 경우     </span>
<span class="nc">Functional2</span> <span class="n">functional2</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span><span class="o">)</span> <span class="o">};</span>

<span class="c1">// 2. 매개변수의 타입을 생략한 경우   </span>
<span class="nc">Functional2</span> <span class="n">functional2</span> <span class="o">=</span> <span class="o">(</span><span class="n">name</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span><span class="o">)</span> <span class="o">};</span>    

<span class="c1">// 3. 매개변수가 한개여서 소괄호를 생략한 경우    </span>
<span class="nc">Functional2</span> <span class="n">functional2</span> <span class="o">=</span> <span class="n">name</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span><span class="o">)</span> <span class="o">};</span>          

<span class="c1">// 4. 실행 코드가 한 줄이어서 중괄호를 생략한 경우    </span>
<span class="nc">Functional2</span> <span class="n">functional2</span> <span class="o">=</span> <span class="n">name</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>    

<span class="c1">// 5. 매개변수가 없어서 소괄호를 생략할 수 없는 경우    </span>
<span class="nc">Functional3</span> <span class="n">functional3</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"functiona3"</span><span class="o">);</span>    

<span class="c1">// 6. 반환값이 있는 경우 return 키워드 사용하는 경우     </span>
<span class="nc">Functional</span> <span class="n">functional</span> <span class="o">=</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"print"</span><span class="o">);</span>
       <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">;</span>
<span class="o">};</span>

<span class="c1">// 7. 실행 코드가 반환 코드만 존재하는 경우 키워드와 중괄호 생략한 경우    </span>
<span class="nc">Functional</span> <span class="n">functional</span> <span class="o">=</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">;</span>
</code></pre></div></div>

<h2 id="12-람다식의-등장배경과-장단점">1.2 람다식의 등장배경과 장단점</h2>

<p>하나의 CPU 안에 다수의 코어를 삽입하는 멀티 코어 프로세서들이 등장하면서 
일반 프로그래머에게도 병렬화 프로그램에 대한 필요성이 생기기 시작했다.</p>

<p>이러한 추세에 대응 하기 위해 자바8 에서는 병렬화를 위한 
컬렉션(배열, List, Set, Map)을 강화했고, 이러한 컬렉션을 더 효율적으로 
사용하기 위해 스트림이 추가되었고 또 스트림을 효율적으로 사용하기 위해 
함수형 프로그램이, 다시 함수형 프로그래밍을 위해 람다가, 또 
람다를 지원하기 위한 함수형 인터페이스가 나오게 되었다.</p>

<p>아래와 같이 정리해 볼 수 있다.</p>

<blockquote>
  <p>빅데이터 지원 -&gt; 병렬화 강화 -&gt; 컬렉션 강화 -&gt; 스트림 강화 -&gt; 람다 도입 -&gt; 인터페이스 명세 변경 -&gt; 함수형 인터페이스 도입</p>
</blockquote>

<h4 id="장점">장점</h4>

<ul>
  <li>코드를 간결하게 만들 수 있어 가독성이 향상된다.</li>
  <li>멀티쓰레드 환경에서 병렬처리가 가능하다.</li>
  <li>람다는 지연연산을 수행 함으로써 불필요한 연산을 최소화 할 수 있다. (지연 연산)</li>
  <li>함수를 만드는 과정 없이 한번에 처리하기에 생산성이 높아진다.</li>
</ul>

<h4 id="단점">단점</h4>

<ul>
  <li>람다로 인한 무명함수는 재사용이 불가능하다.</li>
  <li>stream() 에서 람다를 사용할 시에 단순 for문 혹은 while 보다 성능이 떨어진다.</li>
  <li>람다를 무분별하게 사용하면 코드가 클린하지 못하다.</li>
</ul>

<h2 id="13-람다식의-타입과-형변환">1.3 람다식의 타입과 형변환</h2>

<p>함수형 인터페이스로 람다식을 참조할 수 있는 것일 뿐이지 
람다식의 타입이 함수형 인터페이스의 타입과 일치하는 것은 아니다. <br />
람다식은 익명 객체에서 온것이고 익명 객체는 타입이 없다.</p>

<p>정확히는 타입은 있지만 컴파일러가 임의로 이름을 정하기 때문에 알 수 없는 것이다. 
그래서 대입 연산자의 양변의 타입을 일치시키기 위해 형변환이 필요하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">MyFunction</span> <span class="n">f</span> <span class="o">=</span> <span class="o">(</span><span class="nc">MyFunction</span><span class="o">)(</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="o">}</span> <span class="o">);</span>   
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">람다식은 MyFunction 인터페이스를 직접 구현하지 않았지만, 이 인터페이스를 구현한 
클래스의 객체와 완전히 동일하기 때문에 위와 같은 형변환을 허용한다. 그리고 
이 형변환은 생략 가능하다.</code></p>

<p>참고로 람다식은 이름이 없을 뿐 분명히 객체인데도, Object 타입으로 형변환 
할 수 없다. 람다식은 오직 함수형 인터페이스로만 형변환이 가능하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Object</span><span class="o">)(</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="o">}</span> <span class="o">);</span> <span class="c1">// error. 함수형 인터페이스로만 가능    </span>
</code></pre></div></div>

<p>굳이 변경하고자 한다면, 함수형 인터페이스로 변환하고 난 후에 가능하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="o">(</span><span class="nc">MyFunction02</span><span class="o">)(()</span> <span class="o">-&gt;</span> <span class="o">{});</span>   
</code></pre></div></div>

<hr />

<h1 id="2-함수형-인터페이스란">2. 함수형 인터페이스란?</h1>

<p><code class="language-plaintext highlighter-rouge">함수형 인터페이스는 추상 메서드가 하나뿐인 인터페이스이다.</code>      <br />
<code class="language-plaintext highlighter-rouge">함수형 인터페이스(Functional Interface)를 사용하는 이유는 자바의 람다식은 
함수형 인터페이스로만 접근이 가능하기 때문이다.</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Functional</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">cal</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">Functional</span> <span class="n">functional</span> <span class="o">=</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span><span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">functional</span><span class="o">.</span><span class="na">cal</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span> <span class="o">));</span> <span class="c1">// 출력 : 5   </span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>또한 @FunctionalInterface 를 사용하면 다른 사람이 추상 메서드를 추가하는 
상황을 예방할 수 있다.  <br />
추상 메서드가 1개만 선언되었는지 확인해주며, 만약 2개 이상 추상메서드가 
정의된다면 에러 메시지를 보여주게 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Functional</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">cal</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">);</span>  <span class="c1">// 추상 메서드는 오로지 1개만 있어야 한다.  </span>

    <span class="c1">// static 메서드가 있어도 된다.</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">bbb</span><span class="o">()</span> <span class="o">{}</span>

    <span class="c1">// default 메서드가 있어도 된다.</span>
    <span class="k">default</span> <span class="kt">void</span> <span class="nf">ccc</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위처럼 사용이 가능하다.</p>

<h3 id="21-java에서-기본으로-제공하는-함수형-인터페이스">2.1 Java에서 기본으로 제공하는 함수형 인터페이스</h3>

<p>자바에서 미리 정의해둔 자주 사용할만한 Functional Interface를 알아보자.</p>

<ul>
  <li>Function</li>
  <li>BiFunction</li>
  <li>UnaryOperator</li>
  <li>Consumer</li>
  <li>Supplier</li>
  <li>Predicate</li>
  <li>Runnable ( 멀티 쓰레드 )</li>
  <li>등등</li>
</ul>

<p>더 자세한 내용은 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html">docs</a> 참고하자.</p>

<h4 id="211-functiont-r">2.1.1 Function&lt;T, R&gt;</h4>

<p><code class="language-plaintext highlighter-rouge">값을 하나 받아서 리턴하는 일반적인 함수</code></p>

<ul>
  <li>별명 : 트랜스포머(변신로봇)</li>
  <li>이유 : 값을 변환하여 리턴하기 때문</li>
</ul>

<h5 id="apply">apply</h5>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
     * Applies this function to the given argument.
     *
     * @param t the function argument
     * @return the function result
     */</span>
    <span class="no">R</span> <span class="nf">apply</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">plus</span> <span class="o">=</span> <span class="o">(</span><span class="n">number</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">number</span> <span class="o">+</span> <span class="mi">10</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">plus</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">5</span><span class="o">));</span> <span class="c1">// 출력 : 15</span>
</code></pre></div></div>

<p>또한 T의 매개변수를 받아서 R로 리턴한다는 것은 위처럼 같은 Integer 타입만을 의미하는 것은 아니다.  <br />
아래와 같이 Integer 타입을 받아서 다른 타입으로 변경이 가능하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Function&lt;Integer, Double&gt;  </span>
<span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="n">function</span> <span class="o">=</span> <span class="n">integer</span> <span class="o">-&gt;</span> <span class="nc">Double</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">integer</span><span class="o">);</span>
</code></pre></div></div>

<h5 id="compose">compose</h5>

<p>입력값을 가지고 먼저 뒤에 오는 함수를 적용한다. <br />
그 결과값을 가지고 입력값으로 사용하는 것이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">plus1</span> <span class="o">=</span> <span class="o">(</span><span class="n">number</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">number</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>
<span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">plus2</span> <span class="o">=</span> <span class="o">(</span><span class="n">number</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">number</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

<span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">compose</span> <span class="o">=</span> <span class="n">plus1</span><span class="o">.</span><span class="na">compose</span><span class="o">(</span><span class="n">plus2</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">compose</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">5</span><span class="o">));</span> <span class="c1">// 출력 : 12 </span>
</code></pre></div></div>

<h5 id="andthen">andThen</h5>

<p>compose와 반대로 먼저 적용하고 뒤에 오는 함수를 적용한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">plus1</span> <span class="o">=</span> <span class="o">(</span><span class="n">number</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">number</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>
<span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">plus2</span> <span class="o">=</span> <span class="o">(</span><span class="n">number</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">number</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

<span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">compose</span> <span class="o">=</span> <span class="n">plus1</span><span class="o">.</span><span class="na">andThen</span><span class="o">(</span><span class="n">plus2</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">compose</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">5</span><span class="o">));</span> <span class="c1">// 출력 : 11</span>
</code></pre></div></div>

<h4 id="212-bifunctiont-u-r">2.1.2 BiFunction&lt;T, U, R&gt;</h4>

<p><code class="language-plaintext highlighter-rouge">Function과 유사하지만 입력값을 2개를 받는 것이다.</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// (T, U) -&gt; R   </span>

<span class="nc">BiFunction</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">U</span><span class="o">,</span> <span class="no">R</span><span class="o">&gt;</span>
</code></pre></div></div>

<h4 id="213-unaryoperator">2.1.3 UnaryOperator<T></T></h4>

<p><code class="language-plaintext highlighter-rouge">Function&lt;T, R&gt;의 특수한 형태이며 입력값을 하나 받아서 동일한 
타입을 리턴하는 함수</code></p>

<p>입력/리턴 값이 같으므로 이전의 Function을 아래와 같이 변경 가능하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Function&lt;Integer, Integer&gt; plus10 = (number) -&gt; number + 10;</span>
<span class="nc">UnaryOperator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">plus10</span> <span class="o">=</span> <span class="o">(</span><span class="n">number</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">number</span> <span class="o">+</span> <span class="mi">10</span><span class="o">;</span>


<span class="c1">// Function&lt;Integer, Integer&gt; multiply2 = (number) -&gt; number * 2;</span>
<span class="nc">UnaryOperator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">multiply2</span> <span class="o">=</span> <span class="o">(</span><span class="n">number</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">number</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>
</code></pre></div></div>

<h4 id="214-consumer">2.1.4 Consumer<T></T></h4>

<p><code class="language-plaintext highlighter-rouge">매개변수는 있고 리턴이 없는 함수</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
* Performs this operation on the given argument.
*
* @param t the input argument
*/</span>
<span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>   
</code></pre></div></div>

<ul>
  <li>별명 : Spartan(스파르탄)</li>
  <li>이유 : 모든 것을 빼앗고 아무것도 내주지 마라!</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Consumer</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">print</span> <span class="o">=</span> <span class="nc">Integer</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"print"</span><span class="o">);</span>   
<span class="n">print</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>   
</code></pre></div></div>

<h4 id="215-supplier">2.1.5 Supplier<T></T></h4>

<p><code class="language-plaintext highlighter-rouge">T 타입의 값을 제공해주는 함수</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
* Gets a result.
*
* @return a result
*/</span>
<span class="no">T</span> <span class="nf">get</span><span class="o">();</span>
</code></pre></div></div>

<ul>
  <li>별명 : 게으른 공급자</li>
  <li>이유 : 입력값이 존재하지 않는데, 내가 원하는 것을 미리 준비하기 때문에</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">get10</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="mi">10</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">get10</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
</code></pre></div></div>

<h4 id="216-predicate">2.1.6 Predicate<T></T></h4>

<p><code class="language-plaintext highlighter-rouge">T타입의 값을 받아서 boolean을 반환하는 함수 인터페이스이며, 
    여러 조건식들을 논리 연산자인 and, or, not 등으로 연결해서 하나의 식으로 
    구성할 수 있는 것처럼 여러 Predicate를 and(), or(), negate()로 연결해서 
    하나의 새로운 Predicate로 결합할 수 있다.</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">boolean</span> <span class="nf">test</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>
</code></pre></div></div>

<ul>
  <li>별명: 판사</li>
  <li>이유 : 참과 거짓으로 판단하기 때문에</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Predicate</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">predicate</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span>
<span class="kt">boolean</span> <span class="n">test</span> <span class="o">=</span> <span class="n">predicate</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">test</span><span class="o">);</span> <span class="c1">// true  </span>
</code></pre></div></div>

<hr />

<h1 id="3-variable-capture">3. Variable Capture</h1>

<p>람다식의 실행 코드 블록 내에서 클래스의 멤버 필드와 멤버 메서드, 그리고 
지역 변수를 사용할 수 있다.  <br />
클래스의 멤버 필드와 멤버 메서드는 특별한 제약 없이 사용 가능하지만, 
    지역변수를 사용함에 있어서는 제약이 존재한다. <br />
이 내용을 잘 이해하기 위해서는 JVM의 메모리 구조에 대해 잘 알고 있어야 한다.</p>

<p>이를 이해하기 위한 개념들에 대해 잠깐 살명해 보면</p>

<ol>
  <li>
    <p>클래스의 멤버 메서드의 매개변수와 이 메서드 실행 블록 내부의 지역 변수는 
JVM의 stack에 생성되고 메서드 실행이 끝나면 stack에서 사라진다.</p>
  </li>
  <li>
    <p>new 연산자를 사용해서 생성한 객체는 JVM의 heap 영역에 객체가 생성되고 GC(Garbage Collector)에 의해 
관리되며, 더 이상 사용하지 않는 객체에 대해 필요한 경우 메모리에서 제거한다.</p>
  </li>
</ol>

<p><code class="language-plaintext highlighter-rouge">heap에 생성된 객체가 stack의 변수를 사용하려고 하는데, 사용하려는 시점에 stack에 
더이상 해당 변수가 존재하지 않을 수 있다.</code> <br />
<code class="language-plaintext highlighter-rouge">왜냐하면 stack은 메서드 실행이 끝나면 매개변수나 지역변수에 대해 제거하기 때문이다. 그래서 더 이상 존재하지 않는 
변수를 사용하려 할 수 있기 때문에 오류가 발생한다.</code></p>

<p><strong>자바는 이 문제를 Variable Capture라고 하는 값 복사를 사용해서 해결하고 있다.</strong></p>

<p>아래 예제를 살펴보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">VariableCapture</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">VariableCapture</span> <span class="n">capture</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">VariableCapture</span><span class="o">();</span>
        <span class="n">capture</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"로컬 변수"</span><span class="o">;</span>

        <span class="kd">class</span> <span class="nc">LocalClass</span> <span class="o">{</span>
            <span class="kt">void</span> <span class="nf">printStr</span><span class="o">()</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>run 메서드에서 갖고 있는 변수 str은 run 메서드 실행이 완료되면 사라진다.  <br />
그런데 <code class="language-plaintext highlighter-rouge">run 메서드 안의 로컬 클래스인 LocalClass에서 testStr을 사용해야 하니까 
자바에서는 값 복사를 해오는데 이를 Variable Capture이다.</code></p>

<p>이것은 내부 클래스에서 뿐만 아니라, 익명클래스, 람다 등에서 발생 할 수 있다.</p>

<p>자바 8이전에는 로컬 변수를 참조 할 때 final 키워드를 사용해야 Variable Capture을 
할 수 있었다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
	<span class="kd">final</span> <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"변수 캡처"</span><span class="o">;</span> <span class="c1">// 자바 8 이전 에는 final 키워드 필수</span>

	<span class="kd">class</span> <span class="nc">LocalClass</span> <span class="o">{</span>
		<span class="kt">void</span> <span class="nf">printStr</span><span class="o">()</span> <span class="o">{</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>final 키워드를 사용하지 않은 경우 concurrency 문제가 생길 수 있어서 컴파일러가 
방지한다.</p>

<p>그러나, 자바 8부터는 effective final을 지원해 final 키워드를 사용하지 않은 변수를 
로컬 클래스, 익명 클래스 구현체 또는 람다에서 참조할 수 있다.</p>

<p><code class="language-plaintext highlighter-rouge">effective final 사실상 final이란 변수가 추후 변경되지 않은 상황의 변수를 지칭하는데, 
    나중에 변수가 변경된다면?, effective final이 아니라면?</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">VariableCapture</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">VariableCapture</span> <span class="n">capture</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">VariableCapture</span><span class="o">();</span>
        <span class="n">capture</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">baseNumber</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>

        <span class="kd">class</span> <span class="nc">LocalClass</span> <span class="o">{</span>
            <span class="kt">void</span> <span class="nf">printNumber</span><span class="o">()</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">baseNumber</span><span class="o">);</span> <span class="c1">// 컴파일 에러 발생!</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="nc">Consumer</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">consumer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Consumer</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">integer</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">baseNumber</span><span class="o">);</span> <span class="c1">// 컴파일 에러 발생!</span>
            <span class="o">}</span>
        <span class="o">};</span>

        <span class="nc">IntConsumer</span> <span class="n">intConsumer</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">baseNumber</span><span class="o">);</span> <span class="c1">//컴파일 에러 발생!</span>

        <span class="n">baseNumber</span><span class="o">++;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Variable ‘baseNumber’ is accessed from within inner class, needs to be final or effectively final 같은 
컴파일 에러가 발생한다.</p>

<h3 id="람다-vs-익명-클래스-vs-로컬-클래스">람다 vs 익명 클래스 vs 로컬 클래스</h3>

<h5 id="공통점">공통점</h5>

<ul>
  <li>Variable Capture 지원</li>
  <li>effective final 지원</li>
</ul>

<h5 id="차이점">차이점</h5>

<ul>
  <li>익명클래스, 로컬클래스는 각각의 scope을 가지고 있기 때문에 쉐도잉 지원</li>
  <li>람다는 해당 람다식을 구현한 곳(ex. 메서드)과 같은 scope을 갖기 때문에 쉐도잉을 지원하지 않는다.</li>
</ul>

<p>쉐도잉에 대한 예제는 아래와 같다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">VariableCapture2</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">VariableCapture2</span> <span class="n">test</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">VariableCapture2</span><span class="o">();</span>
		<span class="n">test</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
	<span class="o">}</span>

	<span class="kd">private</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">baseNumber</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>

		<span class="kd">class</span> <span class="nc">LocalClass</span> <span class="o">{</span>
			<span class="kt">void</span> <span class="nf">printNumber</span><span class="o">()</span> <span class="o">{</span>
				<span class="kt">int</span> <span class="n">baseNumber</span> <span class="o">=</span> <span class="mi">11</span><span class="o">;</span>
				<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">baseNumber</span><span class="o">);</span>
			<span class="o">}</span>
		<span class="o">}</span>

		<span class="nc">Consumer</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">consumer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Consumer</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
			<span class="kt">int</span> <span class="n">baseNumber</span> <span class="o">=</span> <span class="mi">13</span><span class="o">;</span>
			<span class="nd">@Override</span>
			<span class="kd">public</span> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">integer</span><span class="o">)</span> <span class="o">{</span>
				<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">baseNumber</span><span class="o">);</span>
			<span class="o">}</span>
		<span class="o">};</span>

		<span class="nc">LocalClass</span> <span class="n">localClass</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LocalClass</span><span class="o">();</span>
		<span class="n">localClass</span><span class="o">.</span><span class="na">printNumber</span><span class="o">();</span>
		<span class="n">consumer</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>output</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>11
13
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">run 메서드의 지역변수인 baseNumber의 값은 10이였는데 로컬 클래스, 익명 클래스와 run 메서드는 
서로 다른 scope에 있기 때문에 가려져서 11과 13이 출력된 것이다. 이것을 
쉐도잉이라고 한다.</code></p>

<p><code class="language-plaintext highlighter-rouge">하지만 람다는 run() 메서드와 같은 scope에 있어서 쉐도잉이 불가능하다.</code></p>

<p><img width="700" alt="스크린샷 2021-03-14 오후 3 12 21" src="https://user-images.githubusercontent.com/26623547/111060098-e3d5a380-84dd-11eb-9340-d7709e7141ad.png" /></p>

<p><img width="700" alt="스크린샷 2021-03-14 오후 4 02 12" src="https://user-images.githubusercontent.com/26623547/111060232-a9203b00-84de-11eb-9167-9ade8dfdd4e6.png" /></p>

<p>위와 같이 같은 scope이라는 컴파일 에러가 발생한다.</p>

<hr />

<h1 id="4-메서드-생성자-레퍼런스">4. 메서드, 생성자 레퍼런스</h1>

<p><code class="language-plaintext highlighter-rouge">메서드, 생성자 레퍼런스는 람다식을 더 간략하게 표현할 수 있게 해준다.</code>       <br />
콜론 두개 ::를 사용하며, 크게 다음과 같이 구분할 수 있다.</p>

<ul>
  <li>static 메서드 참조 -&gt; <code class="language-plaintext highlighter-rouge">타입::static 메서드</code></li>
  <li>특정 객체의 인스턴스 메서드 참조 -&gt; <code class="language-plaintext highlighter-rouge">객체 래퍼런스::인스턴스 메서드</code></li>
  <li>임의 객체의 인스턴스 메서드 참조 -&gt; <code class="language-plaintext highlighter-rouge">타입::인스턴스 메서드</code></li>
  <li>생성자 참조 -&gt; <code class="language-plaintext highlighter-rouge">타입::new</code></li>
</ul>

<p>아래와 같이 예제를 통해서 하나씩 살펴보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Greeting</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Greeting</span><span class="o">(){</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="nf">Greeting</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">hello</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">){</span>
        <span class="k">return</span> <span class="s">"hello "</span> <span class="o">+</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">hi</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">){</span>
        <span class="k">return</span> <span class="s">"hi "</span> <span class="o">+</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">UnaryOperator를 이용해서 static 메서드를 참조하는 예제는 아래와 같다.</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">UnaryOperator</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">usingGreeting</span> <span class="o">=</span> <span class="nl">Greeting:</span><span class="o">:</span><span class="n">hi</span><span class="o">;</span>
        
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">usingGreeting</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="s">"kaven"</span><span class="o">));</span>
<span class="c1">//print : hi kaven</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">아래는 인스턴스 메서드를 사용한 예제이다.</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Greeting</span> <span class="n">greeting</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Greeting</span><span class="o">();</span>
<span class="nc">UnaryOperator</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">usingGreeting</span> <span class="o">=</span> <span class="nl">greeting:</span><span class="o">:</span><span class="n">hello</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">usingGreeting</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="s">"kaven"</span><span class="o">));</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">아래는 생성자를 사용한 예제이며, Supplier와 Function을 각각 사용하였다.</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 입력값은 없는데 반환값은 있는 함수형 인터페이스 &gt; Supplier</span>
<span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">Greeting</span><span class="o">&gt;</span> <span class="n">newGreeting</span> <span class="o">=</span> <span class="nl">Greeting:</span><span class="o">:</span><span class="k">new</span><span class="o">;</span>
<span class="nc">Greeting</span> <span class="n">greeting</span> <span class="o">=</span> <span class="n">newGreeting</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 입력값은 없는데 반환값은 있는 함수형 인터페이스 &gt; Supplier</span>
<span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">Greeting</span><span class="o">&gt;</span> <span class="n">newGreeting</span> <span class="o">=</span> <span class="nl">Greeting:</span><span class="o">:</span><span class="k">new</span><span class="o">;</span>
<span class="nc">Greeting</span> <span class="n">greeting</span> <span class="o">=</span> <span class="n">newGreeting</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">아래는 임의의 객체를 참조하는 메서드 레퍼런스 예제이다.   </code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">names</span> <span class="o">=</span> <span class="o">{</span><span class="s">"D"</span><span class="o">,</span> <span class="s">"B"</span><span class="o">,</span> <span class="s">"C"</span><span class="o">,</span> <span class="s">"A"</span><span class="o">};</span>
<span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">names</span><span class="o">,</span> <span class="nl">String:</span><span class="o">:</span><span class="n">compareToIgnoreCase</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">names</span><span class="o">));</span>
</code></pre></div></div>
<hr />

<p><strong>Reference</strong></p>

<p><a href="https://velog.io/@kwj1270/Lambda">https://velog.io/@kwj1270/Lambda</a><br />
<a href="https://www.notion.so/758e363f9fb04872a604999f8af6a1ae">https://www.notion.so/758e363f9fb04872a604999f8af6a1ae</a><br />
<a href="https://www.notion.so/a875fcd046db4ddd8dce01bf61743f5e">https://www.notion.so/a875fcd046db4ddd8dce01bf61743f5e</a><br />
<a href="https://yadon079.github.io/2021/java%20study%20halle/week-15">https://yadon079.github.io/2021/java%20study%20halle/week-15</a></p>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://zcx6263.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>

<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

:ET