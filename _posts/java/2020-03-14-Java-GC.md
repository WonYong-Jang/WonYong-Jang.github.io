---
layout: post
title: "[Java] GC"
subtitle: "Java Garbage Collection"
comments: true
categories : Java
date: 2020-03-14
background: '/img/posts/spring.png'
---

# GC

`프로그래머는 힙을 사용할 수 있는 만큼 자유롭게 사용하고, 더 이상
사용되지 않는 오브젝트들은 가비지 컬렉션을 담당하는 프로세스가 자동으로
메모리에서 제거하도록 하는 것이 가비지 컬렉션의 기본 개념이다.`   

Heap 영역의 오브젝트 중 stack 에서 도달 불가능한(Unreachable) 오브젝트들은
가비지 컬렉션의 대상이 된다.(더이상 참조하지 않는 오브젝트)      

<img width="770" alt="스크린샷 2020-03-14 오후 6 53 28" src="https://user-images.githubusercontent.com/26623547/76679593-2c395780-6625-11ea-8496-33e6f8df0574.png">      


## Garbage Collection 과정     

**Mark and Sweep** 이라고도 한다 ( GC가 스택의 모든 변수를 스캔하면서 각각 어떤
오브젝트를 레퍼런스 하고 있는지 찾는 과정이 Mark 다. Reachable 오브젝트가
레퍼런스하고 있는 오브젝트 또한 marking 한다.     

`여기서 주의할 점은 첫번째 단계인 marking 작업을 위해 모든 스레드는 중단
되는데 이를 stop the world 라고 부른다.(System.gc() 를 생각 없이 호출하면 안되는 이유!!)`        

`그리고 나서 mark 되어있지 않은 모든 오브젝트들을 힙에서 제거하는 과정이 Sweep 이다.`    

`즉, GC 는 garbase를 수집하는 것이 아니라 garbase 가 아닌 것을 따로 mark 하고 있고
그 외의 것은 모두 지우는 것!`    


`System.gc() 를 코드단에서 호출하게 되면 모든 스레드가 중단되기 때문에 사용하지 말것 !`    


> GC가 역할을 하는 시간은 정확히 언제인지를 알수 없음( 참조가 없어지자마자 해제되는 것을 보장하지 않음)    


특히 Full GC가 일어나서 수 초간 모든 쓰레드가 정지한다면 장애로 이어지는 치명적인 문제가 생길 수 있다.

- - - 

## GC 의 구조 

#### Reachability    

Java의 GC는 가비지 객체를 판별하기 위해 reachability 라는 개념을 사용한다.     
어떤 객체에 유효한 참조가 있으면 reachable, 없으면 unreachable 로 구분하고 가비지로 간주한다.     

바꿔 말하면 객체에 대한 reachability를 제어 할수 있다면 코드를 통해 GC에 일부 관여하는 것이 가능하다.    

`java는 이를 위해서 SoftReference, WeakReference 등 제공한다.`    

또한, 캐시 등을 만들 때 메모리 누수 조심해야 한다.
캐시의 키가 원래 데이터에서 삭제 된다면 캐시 내부의 키와 값은 더이상 의미 없는
데이터 이지만 GC는 삭제된 캐시의 키를 가비지로 인식 못한다. 캐시에 Weak Reference를 넣어준다면
이러한 문제 방지 가능하다 (WeakHashMap)


<img width="900" alt="스크린샷 2020-02-02 오후 10 37 38" src="https://user-images.githubusercontent.com/26623547/76682457-bdb5c300-663f-11ea-98f9-5a20bb657a26.png">   
<img width="700" alt="스크린샷 2020-03-14 오후 9 59 15" src="https://user-images.githubusercontent.com/26623547/76682398-408a4e00-663f-11ea-96ad-eba3f3110aaf.png">   

`JVM의 Heap내에서 객체의 수명을 관리하기 위해 Young, Old 구역으로 나뉜다.`       

`Young 영역은 다시 Eden 영역과 Survivor 영역으로 나뉜다.`   

#### Eden 영역    

`Object가 최초로 Heap에 할당되는 장소이다.` 만일 Eden 영역이 가득 찼다면, 
    Minor GC가 발생하게 되고 그러면 Object의
참조 여부를 파악하고 Reachable 오브젝트는 Survivor 영역으로 넘긴다.    
그리고 참조가 사라진 Garbage 오브젝트이면 남겨 놓는다.    
모든 Reachable 오브젝트가Survivor 영역으로 넘어간다면 Eden 영역을 모두 청소한다.

Survior 영역은 Survivor0, 1 두 개의 영역이 있고 Eden 영역에서 
살아남은 Object는 두 영역 중 한 군데로 이동하게 된다.   

#### Survivor 영역    

`Survivor0 과 Survivor1 로 구성되며 Eden 영역에 살아 남은 Object들이 잠시 머무르는
곳`이며 Reachable 오브젝트들은 하나의 Survivor 영역만 사용하게 되며 이러한
전반적인 과정을 **Minor GC** 라고 한다.   

> Minor GC 가 발동할 때마다, Survivor 영역에 있던 객체들은 다른 Survivor 영역으로 이동한다.   
> 즉, 최초에 Survivor 0 영역에 있던 객체는, Minor GC가 발동하면 Survivor 1 영역으로 이동하게 된다.   

#### Old Generation 영역    

새로 Heap에 할당된 Object가 들어오는 것이 아닌, Survivor 영역에서 살아남아
오랫동안 참조 되었고 앞으로도 사용될 확률이 높은 Object들을 저장하는 영역이다.
`이러한 과정 중 Old Generation의 메모리가 충분하지 않으면 해당 영역에서 GC가 발생하는데
이을 Major GC라고 한다.`    

위에서 살펴봤듯이 Young 영역이 꽉차면, 이 메모리 영역에서 살아 남은 Object를 
Old 영역으로 옴기게 되는데 그 이유에 대해서 생각을 해보자.   

`보통 새로 할당된 영역에서는 대부분의 객체들이 빠르게 해제되고 오래된 
영역에서는 객체들이 변하지 않을 확률이 높으므로, 이 기법은 메모리의 
일부 영역만을 주기적으로 수집하게 되는 장점이 있다.`   

#### Perm 영역   

보통 class Meta 정보나 Method의 Meta정보, static 변수와 상수 정보들이 저장되는 공간으로
흔히 <b>메타데이터 저장 영역이라고 한다.</b> Java8 부터 Native Memory 영역으로 이동하였다.


- - - 

Reference    


<https://yaboong.github.io/java/2018/05/26/java-memory-management/>



{% highlight ruby linenos %}

{% endhighlight %}


{%- if site.disqus.shortname -%}
    {%- include disqus.html -%}
{%- endif -%}

